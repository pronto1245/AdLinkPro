import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import bcrypt from "bcrypt";
import jwt from "jsonwebtoken";
import { insertUserSchema, insertOfferSchema, insertTicketSchema, type User } from "@shared/schema";
import { z } from "zod";
import express from "express";

// Extend Express Request to include user property
declare global {
  namespace Express {
    interface Request {
      user?: User;
    }
  }
}

const JWT_SECRET = process.env.JWT_SECRET || "your-secret-key";

// Auth middleware
const authenticateToken = async (req: Request, res: Response, next: NextFunction) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.sendStatus(401);
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET) as any;
    const user = await storage.getUser(decoded.id);
    if (!user) {
      return res.sendStatus(403);
    }
    req.user = user;
    next();
  } catch (error) {
    return res.sendStatus(403);
  }
};

// Role-based access control
const requireRole = (roles: string[]) => {
  return (req: Request, res: Response, next: NextFunction) => {
    if (!req.user || !roles.includes(req.user.role)) {
      return res.sendStatus(403);
    }
    next();
  };
};

export async function registerRoutes(app: Express): Promise<Server> {
  app.use(express.json());

  // Auth routes
  app.post("/api/auth/login", async (req, res) => {
    try {
      const { username, password } = req.body;
      
      if (!username || !password) {
        return res.status(400).json({ error: "Username and password required" });
      }

      const user = await storage.getUserByUsername(username) || await storage.getUserByEmail(username);
      
      if (!user) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const isValidPassword = await bcrypt.compare(password, user.password);
      
      if (!isValidPassword) {
        return res.status(401).json({ error: "Invalid credentials" });
      }

      const token = jwt.sign(
        { 
          id: user.id, 
          username: user.username, 
          role: user.role,
          advertiserId: user.advertiserId 
        },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Update last login
      await storage.updateUser(user.id, { lastLoginAt: new Date() });

      res.json({ 
        token, 
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName,
          company: user.company,
          language: user.language,
          advertiserId: user.advertiserId
        } 
      });
    } catch (error) {
      console.error("Login error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/auth/register", async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByUsername(userData.username) || 
                          await storage.getUserByEmail(userData.email);
      
      if (existingUser) {
        return res.status(400).json({ error: "User already exists" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      
      const user = await storage.createUser({
        ...userData,
        password: hashedPassword,
      });

      const token = jwt.sign(
        { 
          id: user.id, 
          username: user.username, 
          role: user.role,
          advertiserId: user.advertiserId 
        },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      res.status(201).json({ 
        token, 
        user: { 
          id: user.id, 
          username: user.username, 
          email: user.email,
          role: user.role,
          firstName: user.firstName,
          lastName: user.lastName
        } 
      });
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Registration error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Protected routes
  app.get("/api/auth/me", authenticateToken, async (req, res) => {
    try {
      const user = await storage.getUser(req.user.id);
      if (!user) {
        return res.status(404).json({ error: "User not found" });
      }
      
      const { password, ...userWithoutPassword } = user;
      res.json(userWithoutPassword);
    } catch (error) {
      console.error("Get user error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Dashboard metrics
  app.get("/api/dashboard/metrics", authenticateToken, async (req, res) => {
    try {
      const metrics = await storage.getDashboardMetrics(req.user.role, req.user.id);
      res.json(metrics);
    } catch (error) {
      console.error("Dashboard metrics error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // User management (Super Admin only)
  app.get("/api/users", authenticateToken, requireRole(['super_admin']), async (req, res) => {
    try {
      const { role } = req.query;
      const users = await storage.getUsers(role as string);
      
      // Remove passwords from response
      const safeUsers = users.map(({ password, ...user }) => user);
      res.json(safeUsers);
    } catch (error) {
      console.error("Get users error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/users", authenticateToken, requireRole(['super_admin']), async (req, res) => {
    try {
      const userData = insertUserSchema.parse(req.body);
      
      // Check if user already exists
      const existingUser = await storage.getUserByUsername(userData.username) || 
                          await storage.getUserByEmail(userData.email);
      
      if (existingUser) {
        return res.status(400).json({ error: "User already exists" });
      }

      // Hash password
      const hashedPassword = await bcrypt.hash(userData.password, 10);
      
      const user = await storage.createUser({
        ...userData,
        password: hashedPassword,
      });

      const { password, ...userWithoutPassword } = user;
      res.status(201).json(userWithoutPassword);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Create user error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Offer management
  app.get("/api/offers", authenticateToken, async (req, res) => {
    try {
      let offers;
      
      if (req.user.role === 'super_admin') {
        offers = await storage.getOffers();
      } else if (req.user.role === 'advertiser') {
        offers = await storage.getOffers(req.user.id);
      } else if (req.user.role === 'affiliate') {
        // Get offers available to this affiliate
        const partnerOffers = await storage.getPartnerOffers(req.user.id);
        const offerIds = partnerOffers.map(po => po.offerId);
        
        if (offerIds.length > 0) {
          offers = await storage.getOffers();
          offers = offers.filter(offer => offerIds.includes(offer.id) || !offer.isPrivate);
        } else {
          offers = await storage.getOffers();
          offers = offers.filter(offer => !offer.isPrivate);
        }
      }
      
      res.json(offers);
    } catch (error) {
      console.error("Get offers error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/offers", authenticateToken, requireRole(['super_admin', 'advertiser']), async (req, res) => {
    try {
      const offerData = insertOfferSchema.parse(req.body);
      
      // Set advertiser ID based on user role
      if (req.user.role === 'advertiser') {
        offerData.advertiserId = req.user.id;
      }
      
      const offer = await storage.createOffer(offerData);
      res.status(201).json(offer);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Create offer error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.put("/api/offers/:id", authenticateToken, requireRole(['super_admin', 'advertiser']), async (req, res) => {
    try {
      const { id } = req.params;
      const offerData = req.body;
      
      // Check if user owns this offer (for advertisers)
      if (req.user.role === 'advertiser') {
        const existingOffer = await storage.getOffer(id);
        if (!existingOffer || existingOffer.advertiserId !== req.user.id) {
          return res.status(403).json({ error: "Access denied" });
        }
      }
      
      const offer = await storage.updateOffer(id, offerData);
      res.json(offer);
    } catch (error) {
      console.error("Update offer error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Tracking links
  app.get("/api/tracking-links", authenticateToken, requireRole(['affiliate']), async (req, res) => {
    try {
      const links = await storage.getTrackingLinks(req.user.id);
      res.json(links);
    } catch (error) {
      console.error("Get tracking links error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/tracking-links", authenticateToken, requireRole(['affiliate']), async (req, res) => {
    try {
      const { offerId, subId1, subId2, subId3, subId4, subId5 } = req.body;
      
      // Check if affiliate has access to this offer
      const partnerOffers = await storage.getPartnerOffers(req.user.id, offerId);
      const offer = await storage.getOffer(offerId);
      
      if (!offer) {
        return res.status(404).json({ error: "Offer not found" });
      }
      
      if (offer.isPrivate && partnerOffers.length === 0) {
        return res.status(403).json({ error: "Access denied to this offer" });
      }
      
      // Generate unique tracking code
      const trackingCode = `${req.user.id.slice(0, 8)}_${offerId.slice(0, 8)}_${Date.now().toString(36)}`;
      
      const link = await storage.createTrackingLink({
        partnerId: req.user.id,
        offerId,
        trackingCode,
        url: `${process.env.TRACKING_DOMAIN || 'http://localhost:5000'}/track/${trackingCode}`,
        subId1,
        subId2,
        subId3,
        subId4,
        subId5,
      });
      
      res.status(201).json(link);
    } catch (error) {
      console.error("Create tracking link error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Statistics
  app.get("/api/statistics", authenticateToken, async (req, res) => {
    try {
      const { startDate, endDate, offerId } = req.query;
      
      const filters: any = {};
      
      if (req.user.role === 'affiliate') {
        filters.partnerId = req.user.id;
      } else if (req.user.role === 'advertiser') {
        // Get offers belonging to this advertiser
        const offers = await storage.getOffers(req.user.id);
        const offerIds = offers.map(offer => offer.id);
        if (offerIds.length === 0) {
          return res.json([]);
        }
        // Note: This would need to be implemented in storage to filter by multiple offer IDs
      }
      
      if (offerId) filters.offerId = offerId as string;
      if (startDate) filters.startDate = new Date(startDate as string);
      if (endDate) filters.endDate = new Date(endDate as string);
      
      const stats = await storage.getStatistics(filters);
      res.json(stats);
    } catch (error) {
      console.error("Get statistics error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Transactions
  app.get("/api/transactions", authenticateToken, async (req, res) => {
    try {
      let transactions;
      
      if (req.user.role === 'super_admin') {
        transactions = await storage.getTransactions();
      } else {
        transactions = await storage.getTransactions(req.user.id);
      }
      
      res.json(transactions);
    } catch (error) {
      console.error("Get transactions error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Support tickets
  app.get("/api/tickets", authenticateToken, async (req, res) => {
    try {
      let tickets;
      
      if (req.user.role === 'super_admin') {
        tickets = await storage.getTickets();
      } else {
        tickets = await storage.getTickets(req.user.id);
      }
      
      res.json(tickets);
    } catch (error) {
      console.error("Get tickets error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.post("/api/tickets", authenticateToken, async (req, res) => {
    try {
      const ticketData = insertTicketSchema.parse({
        ...req.body,
        userId: req.user.id,
      });
      
      const ticket = await storage.createTicket(ticketData);
      res.status(201).json(ticket);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ error: error.errors });
      }
      console.error("Create ticket error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Fraud alerts
  app.get("/api/fraud-alerts", authenticateToken, requireRole(['super_admin']), async (req, res) => {
    try {
      const alerts = await storage.getFraudAlerts();
      res.json(alerts);
    } catch (error) {
      console.error("Get fraud alerts error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Postbacks
  app.get("/api/postbacks", authenticateToken, async (req, res) => {
    try {
      const postbacks = await storage.getPostbacks(req.user.id);
      res.json(postbacks);
    } catch (error) {
      console.error("Get postbacks error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  // Partner offer management
  app.post("/api/partner-offers", authenticateToken, requireRole(['super_admin', 'advertiser']), async (req, res) => {
    try {
      const { partnerId, offerId, customPayout } = req.body;
      
      // Check if advertiser owns the offer
      if (req.user.role === 'advertiser') {
        const offer = await storage.getOffer(offerId);
        if (!offer || offer.advertiserId !== req.user.id) {
          return res.status(403).json({ error: "Access denied" });
        }
      }
      
      const partnerOffer = await storage.createPartnerOffer({
        partnerId,
        offerId,
        customPayout,
        isApproved: req.user.role === 'super_admin', // Super admin auto-approves
      });
      
      res.status(201).json(partnerOffer);
    } catch (error) {
      console.error("Create partner offer error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  app.put("/api/partner-offers/:id", authenticateToken, requireRole(['super_admin', 'advertiser']), async (req, res) => {
    try {
      const { id } = req.params;
      const data = req.body;
      
      const partnerOffer = await storage.updatePartnerOffer(id, data);
      res.json(partnerOffer);
    } catch (error) {
      console.error("Update partner offer error:", error);
      res.status(500).json({ error: "Internal server error" });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
